#!/usr/bin/env python

# thot package for statistical machine translation
# Copyright (C) 2017 Adam Harasimowicz
 
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version.
 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
 
# You should have received a copy of the GNU Lesser General Public License
# along with this program; If not, see <http://www.gnu.org/licenses/>.

"""
Converts log file generated by Thot server to serialize output
from concurrent threads and make it more readable.
"""

import argparse
import re
from collections import defaultdict, deque


def extract_thread_id(line):
    """
    Look for thread ID in passed log line. If there is not the ID
    then it returns None.
    """
    match = re.match('0x[0-9a-f]+\t', line)

    if match:
        return match.group(0)
    else:
        return None


def is_first_request_line(line):
    match = re.search('0x[0-9a-f]+\t-{52}', line)

    return match is not None


def is_last_request_line(line):
    match = re.search('0x[0-9a-f]+\tElapsed time: [0-9]+\.[0-9]+ secs', line)

    return match is not None


def group_thread_output(logFileName):
    # Buffer request logs until they are not complete
    # For each TID we store list of printed lines in the log
    unfinished_output_buf = defaultdict(list)
    # Records the order of request arriving
    request_order = deque()
    # Buffer for complete request logs
    # For each TID we store list of completed request outputs
    # Single request output contains many lines
    finished_output_buf = defaultdict(deque)

    with open(logFileName, 'r') as f:
        for line in f:
            tid = extract_thread_id(line)
            if tid is None:
                print line,
            else:
                unfinished_output_buf[tid].append(line)

                # Add request TID to the queue to remember order of arriving
                if is_first_request_line(line):
                    request_order.append(tid)

                # Move request to buffer with complete logs if it is finished
                if is_last_request_line(line):
                    request_log = ''.join(unfinished_output_buf[tid])
                    finished_output_buf[tid].append(request_log)
                    del unfinished_output_buf[tid]

                # Check if the request from the queue head is ready to print
                if request_order[0] == tid and len(finished_output_buf[tid]) > 0:
                    request_log = finished_output_buf[tid].pop()
                    print request_log,
                    request_order.pop()

    # Print not complete requests
    if len(unfinished_output_buf) > 0:
        print 'WARNING: Some uncompleted information about requests left'
        for _, l in unfinished_output_buf.items():
            print l


if __name__ == '__main__':
    # Parse input arguments
    parser = argparse.ArgumentParser()
    parser.add_argument('logfile', help='Path to log file to convert')
    args = parser.parse_args()

    group_thread_output(args.logfile)